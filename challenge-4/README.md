# Advent of Code 2025 - Day 4: Printing Department

## Problem

Paper rolls (`@`) are arranged on a grid. Forklifts can only access a roll if it has **fewer than 4** paper rolls in its 8 adjacent positions.

**Part 1:** Count how many rolls are accessible by forklifts.

**Part 2:** Forklifts remove accessible rolls iteratively. After each pass, previously blocked rolls may become accessible. Count the total rolls removed until none remain accessible.

## Solution Approach

### Part 1
Store all paper positions in a `HashSet`. For each position, count neighbors using offset deltas and `checked_add_signed` for safe boundary handling. Count positions with < 4 neighbors.

### Part 2
Same logic but iterative: take a snapshot, find all accessible rolls, remove them, repeat until no more are found.

```rust
const NEIGHBORS: [(isize, isize); 8] = [
    (-1, -1), (0, -1), (1, -1),
    (-1,  0),          (1,  0),
    (-1,  1), (0,  1), (1,  1),
];

fn count_paper_neighbors(points: &Points, point: Point) -> usize {
    NEIGHBORS.iter()
        .filter_map(|(dx, dy)| {
            Some((point.0.checked_add_signed(*dx)?, 
                  point.1.checked_add_signed(*dy)?))
        })
        .filter(|pos| points.contains(pos))
        .count()
}
```

## Running

```bash
cargo run
```

Input file should be placed at `.fixtures/input.txt`.

## Complexity

- **Part 1:** O(n) where n = number of paper rolls
- **Part 2:** O(nÂ²) worst case (each pass removes at least one roll)

---

*Disclaimer: The solution code was written manually. This README was generated by AI*
